using System;
using System.Collections.Generic;
using System.Text;

namespace THeaderTools
{
    partial class CodeGenerator
    {
        public void GenCodeCSharp(string targetDir)
        {
            foreach (var i in ClassCollector)
            {
                string genCode = "//This cs is generated by THT.exe\n";

                genCode += "\n\n\n";

                var ns = i.GetNameSpace();
                if (ns == null)
                    ns = "EngineNS";

                genCode += $"namespace {ns}\n";
                genCode += "{\n";
                genCode += GenCppReflectionCSharp(i);
                genCode += "}\n";

                var file = targetDir + i.GetGenFileNameCSharp();
                System.IO.File.WriteAllText(file, genCode); ;
            }
        }
        public string GenCppReflectionCSharp(CppClass klass)
        {
            int nTable = 1;
            string code = GenLine(nTable, $"public struct {klass.Name}{Symbol.NativeSuffix}");
            code += GenLine(nTable, "{");
            nTable++;

            code += GenLine(nTable, "public struct PtrType");
            code += GenLine(nTable, "{");
            nTable++;
            code += GenLine(nTable, "public IntPtr NativePointer;");
            nTable--;
            code += GenLine(nTable, "}");
            code += GenLine(nTable, "private PtrType mPtr;");
            code += GenLine(nTable, "public PtrType Ptr { get => mPtr; }");

            code += GenLine(nTable, "#region Native Wrapper");
            if (klass.Constructors.Count > 0)
            {
                code += GenLine(nTable, "#region Constructor");
                code += CodeGenerator.GenLine(nTable, $"public {klass.Name}(IntPtr InPtr)");
                code += CodeGenerator.GenLine(nTable++, "{");
                code += CodeGenerator.GenLine(nTable, "mPtr.NativePointer = InPtr;");
                code += CodeGenerator.GenLine(--nTable, "}");

                foreach (var i in klass.Constructors)
                {
                    code += i.GenCallBindingCSharp(ref nTable, klass);
                }
                code += GenLine(nTable, "#endregion");
                code += "\n";
            }

            if (klass.Members.Count > 0)
            {
                code += GenLine(nTable, "#region Property");
                foreach (var i in klass.Members)
                {
                    code += i.GenCallBindingCSharp(ref nTable, klass);
                }
                code += GenLine(nTable, "#endregion");
                code += "\n";
            }

            if (klass.Methods.Count > 0)
            {
                code += GenLine(nTable, "#region Method");
                foreach (var i in klass.Methods)
                {
                    code += i.GenCallBindingCSharp(ref nTable, klass); 
                }
                code += GenLine(nTable, "#endregion");
                code += "\n";
            }
            code += GenLine(nTable, "#endregion");

            code += GenLine(nTable, "#region SDK");
            if (klass.Constructors.Count > 0)
            {
                code += "\n";
                foreach (var i in klass.Constructors)
                {
                    code += GenLine(nTable, "[System.Runtime.InteropServices.DllImport(ModuleNC, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]");
                    code += GenLine(nTable, i.GenPInvokeBindingCSharp(klass));
                }
                code += "\n";
            }
            if (klass.Members.Count > 0)
            {
                code += "\n";
                foreach (var i in klass.Members)
                {
                    code += GenLine(nTable, "[System.Runtime.InteropServices.DllImport(ModuleNC, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]");
                    code += GenLine(nTable, i.GenPInvokeBindingCSharp_Getter(klass));
                    code += GenLine(nTable, "[System.Runtime.InteropServices.DllImport(ModuleNC, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]");
                    code += GenLine(nTable, i.GenPInvokeBindingCSharp_Setter(klass));
                }
                code += "\n";
            }
            if (klass.Methods.Count > 0)
            {
                code += "\n";
                foreach (var i in klass.Methods)
                {
                    code += GenLine(nTable, "[System.Runtime.InteropServices.DllImport(ModuleNC, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]");
                    code += GenLine(nTable, i.GenPInvokeBindingCSharp(klass));
                }
                code += "\n";
            }
            code += GenLine(nTable, "#endregion");

            nTable--;
            code += GenLine(nTable, "}");//for struct klass.Name
            return code;
        }
        public static string GenLine(int nTable, string content)
        {
            string codeline = "";
            for(int i=0; i<nTable; i++)
            {
                codeline += "\t";
            }
            codeline += content;
            codeline += "\n";
            return codeline;
        }
    }
}
